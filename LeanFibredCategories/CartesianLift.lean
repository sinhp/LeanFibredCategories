/-
Copyright (c) 2023 Sina Hazratpour. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sina Hazratpour
-/
import Mathlib.CategoryTheory.Category.Cat
import Mathlib.CategoryTheory.Arrow
import Mathlib.CategoryTheory.Opposites
import Mathlib.CategoryTheory.Elements
import Mathlib.CategoryTheory.Equivalence
import Mathlib.CategoryTheory.Grothendieck
import Mathlib.CategoryTheory.MorphismProperty
import Mathlib.CategoryTheory.Iso
import Mathlib.CategoryTheory.Limits.Shapes.Pullbacks
import Mathlib.CategoryTheory.Limits.Preserves.Basic
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks
import LeanFibredCategories.Fiber


universe u

namespace CategoryTheory
open Category Opposite Functor Limits Cones

variable {C E : Type*} [Category C] [Category E]

/-NoteToSelf: we use `structure` declaration rather than subtype definition (akin to `Fib` in `Frobenius.Fiber`) since later we want to extend this structure it to get the **class** `CartBasedLifts`. -/
@[ext]
structure BasedLift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (src : P‚Åª¬π c) (tgt : P‚Åª¬π d) where
hom : (src : E) ‚ü∂ (tgt : E)
over : (P.map hom) ‚â´ eqToHom (tgt.over) = eqToHom (src.2) ‚â´ f

@[ext]
structure UnBasedLift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) where
src : P‚Åª¬π c
tgt : P‚Åª¬π d
hom : (src : E) ‚ü∂ (tgt : E)
over :  (P.map hom) ‚â´ eqToHom (tgt.2) = eqToHom (src.2) ‚â´ f


section
variable (P : E ‚•§ C){c d : C} (f : c ‚ü∂ d){x: P‚Åª¬π c} {y : P‚Åª¬π d}
notation x " ‚ü∂[" f "] " y => BasedLift (P:= _) f x y
end

@[ext]
structure Lift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (tgt : P‚Åª¬π d) where
src : P‚Åª¬π c
lift : BasedLift P f src tgt

@[ext]
structure CoLift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (src : P‚Åª¬π c) where
tgt : P‚Åª¬π d
colift : BasedLift P f src tgt

def HasLift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (x : P‚Åª¬π d) := Nonempty (Lift P f x)

def HasCoLift (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (x : P‚Åª¬π c) := Nonempty (CoLift P f x)

namespace UnBasedLift
variable {P : E ‚•§ C}

@[simp, aesop forward safe]
lemma over_base (f : c ‚ü∂ d) (g : UnBasedLift P f) : P.map g.hom = eqToHom (g.src.2) ‚â´ f ‚â´ (eqToHom (g.tgt.2).symm) := by simp [‚Üê Category.assoc _ _ _, ‚Üê g.over]

/--Coercion from Lift to the total category -/
instance  : CoeOut (UnBasedLift P f) (Œ£ x y : E, x ‚ü∂ y) where
  coe := fun l ‚Ü¶ ‚ü®l.src, l.tgt, l.hom‚ü©

/--Regarding a morphism in Lift P f as a morphism in the total category E. -/
instance  : CoeDep (UnBasedLift P f) (l : UnBasedLift P f) ((l.src : E) ‚ü∂ (l.tgt : E)) where
  coe := l.hom
end UnBasedLift


namespace BasedLift
variable {P : E ‚•§ C}

@[simp, aesop forward safe]
lemma over_base {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} (g : BasedLift P f x y) : P.map g.hom = eqToHom (x.2) ‚â´ f ‚â´ (eqToHom (y.over).symm)  := by simp [‚Üê Category.assoc _ _ _, ‚Üê g.over]

/--Coercion from Based Lift to the total category -/
instance (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (x : P‚Åª¬π c) (y : P‚Åª¬π d) : CoeOut (BasedLift P f x y) ((x : E) ‚ü∂ (y : E)) where
  coe := fun l ‚Ü¶ l.hom

/--Regarding a morphism of the total space as a based lift over its image-/
@[simps]
def tauto {e e' : E} (g : e ‚ü∂ e') : (Fib.tauto e) ‚ü∂[P.map g] (Fib.tauto e') := ‚ü®g, by simp only [Fib.tauto, eqToHom_refl, id_comp, comp_id]‚ü©

@[simps]
instance {e e' : E} {g : e ‚ü∂ e'} : CoeDep (e ‚ü∂ e') (g) (Fib.tauto e  ‚ü∂[P.map g] Fib.tauto e') where
  coe := tauto g

lemma hom_ext {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {g‚ÇÅ g‚ÇÇ : x ‚ü∂[f] y} (h : g‚ÇÅ.hom = g‚ÇÇ.hom) : g‚ÇÅ = g‚ÇÇ := by
  cases g‚ÇÅ; cases g‚ÇÇ; congr

@[simp]
instance instFibHom {c : C} {x y : P‚Åª¬π c} : Coe (x ‚ü∂[ùüô c] y) (x ‚ü∂ y) where
  coe := fun f ‚Ü¶ ‚ü® f.hom , by simp [f.over]‚ü©

@[simps]
def ofFibHom {c : C} {x y : P‚Åª¬π c} (f : x ‚ü∂ y) : x ‚ü∂[ùüô c] y := ‚ü®f.1, by simp [f.2]‚ü©

@[simp, aesop forward safe]
lemma tauto_over_base (f : (P.obj x) ‚ü∂ (P.obj y)) (e : (Fib.tauto x) ‚ü∂[f] (Fib.tauto y)) : P.map e.hom = f := by simp only [Fib.coe_mk, over_base, eqToHom_refl, comp_id, id_comp]

@[simp, aesop forward safe]
def id (x : P‚Åª¬π c) : BasedLift P (ùüô c) x x := ‚ü®ùüô _, by simp‚ü©

@[simp]
lemma id_hom {x : P‚Åª¬π c} : (id x).hom = ùüô _ := rfl

@[simp, aesop forward safe]
def comp {c d d': C} {f : c ‚ü∂ d} {f' : d ‚ü∂ d'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (g : x ‚ü∂[f] y) (g' : y ‚ü∂[f'] z) : x ‚ü∂[f ‚â´ f'] z :=
‚ü®g.hom ‚â´ g'.hom, by simp only [P.map_comp]; rw [assoc, over_base g, over_base g']; simp  ‚ü©

section
variable (P : E ‚•§ C){c d d': C}{x: P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (u : c ‚ü∂ d) (v: d ‚ü∂ d') (f : x ‚ü∂[u] y) (g : y ‚ü∂[v] z)
notation f " ‚â´[l] " g => BasedLift.comp f g
end

@[simp, aesop forward safe]
lemma comp_hom  {c d d': C} {f‚ÇÅ : c ‚ü∂ d} {f‚ÇÇ : d ‚ü∂ d'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (g‚ÇÅ : x ‚ü∂[f‚ÇÅ] y) (g‚ÇÇ : y ‚ü∂[f‚ÇÇ] z) : (g‚ÇÅ ‚â´[l] g‚ÇÇ).hom = g‚ÇÅ.hom ‚â´ g‚ÇÇ.hom := rfl

@[simp]
lemma comp_hom_over {c d d': C} {f‚ÇÅ : c ‚ü∂ d} {f‚ÇÇ : d ‚ü∂ d'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} {g‚ÇÅ : x ‚ü∂[f‚ÇÅ] y} {g‚ÇÇ : y ‚ü∂[f‚ÇÇ] z} {h : x ‚ü∂[f‚ÇÅ ‚â´ f‚ÇÇ] z} : (g‚ÇÅ ‚â´[l] g‚ÇÇ) = h ‚Üî g‚ÇÅ.hom ‚â´ g‚ÇÇ.hom = h.hom := by
constructor
¬∑ intro H; rw [‚Üê H]; simp
¬∑ intro H; ext; simp [H]

@[simp]
lemma comp_tauto_hom {x y z : E} {f : P.obj x ‚ü∂ P.obj y} {l : Fib.tauto x ‚ü∂[f] (Fib.tauto y)} {g : y ‚ü∂ z} : (l ‚â´[l] tauto g).hom = l.hom ‚â´ g := rfl

@[simps]
def eqRebase {c d : C} {f f' : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} (h : f = f') : (x ‚ü∂[f] y) ‚âÉ (x ‚ü∂[f'] y) where
  toFun := fun g ‚Ü¶ ‚ü®g.hom, by rw [‚Üêh, g.over]‚ü©
  invFun := fun g ‚Ü¶ ‚ü®g.hom, by rw [h, g.over]‚ü©
  left_inv := by intro g; simp
  right_inv := by intro g; simp

 --‚ü®g.hom, by simp [g.over]‚ü©
@[simps!]
def eqRebaseToHom {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} :
(x ‚ü∂[f] y) ‚âÉ (x.1 ‚ü∂[(eqToHom x.2) ‚â´ f] y) where
  toFun := fun g => ‚ü®g.hom, by simp [g.over]‚ü©
  invFun := fun g => ‚ü®g.hom, by simp [g.over]‚ü©
  left_inv := by intro g; simp
  right_inv := by intro g; simp

@[simps!]
def eqRebaseAssoc {c' c d d' : C} {u' : c' ‚ü∂ c} {f : c ‚ü∂ d} {u : d ‚ü∂ d'} {x : P‚Åª¬π c'} {y : P‚Åª¬π d'} : (x ‚ü∂[(u' ‚â´ f) ‚â´ u] y) ‚âÉ (x ‚ü∂[u' ‚â´ (f ‚â´ u)] y) := eqRebase (Category.assoc u' f u)

@[simp]
lemma eqRebaseToHom_cancel {c c' d : C} {u : c' ‚ü∂ c} {f : c ‚ü∂ d} {x' : P‚Åª¬π c'} {x : P‚Åª¬π c} {y : P‚Åª¬π d}  {l : x' ‚ü∂[u] x} {g : x ‚ü∂[f] y} {g' : x' ‚ü∂[u ‚â´ f] y} : (l ‚â´[l] g) = g' ‚Üî ((eqRebaseToHom.toFun l) ‚â´[l] g) = eqRebaseAssoc.invFun (eqRebaseToHom.toFun g') := by sorry

@[simp]
lemma assoc {c' c d d' : C} {f‚ÇÅ : c' ‚ü∂ c} {f‚ÇÇ : c ‚ü∂ d} {f‚ÇÉ : d ‚ü∂ d'} {w : P‚Åª¬π c'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (g‚ÇÅ : w ‚ü∂[f‚ÇÅ] x) (g‚ÇÇ : x ‚ü∂[f‚ÇÇ] y) (g‚ÇÉ : y ‚ü∂[f‚ÇÉ] z) :  ((g‚ÇÅ ‚â´[l] g‚ÇÇ) ‚â´[l] g‚ÇÉ) = eqRebaseAssoc.invFun (comp g‚ÇÅ (comp g‚ÇÇ g‚ÇÉ)) := by simp only [comp, Category.assoc, eqRebaseAssoc, eqRebase]

@[simp]
lemma assoc_inv {c' c d d' : C} {f‚ÇÅ : c' ‚ü∂ c} {f‚ÇÇ : c ‚ü∂ d} {f‚ÇÉ : d ‚ü∂ d'} {w : P‚Åª¬π c'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (g‚ÇÅ : w ‚ü∂[f‚ÇÅ] x) (g‚ÇÇ : x ‚ü∂[f‚ÇÇ] y) (g‚ÇÉ : y ‚ü∂[f‚ÇÉ] z) :  eqRebaseAssoc.toFun ((g‚ÇÅ ‚â´[l] g‚ÇÇ) ‚â´[l] g‚ÇÉ) =  (g‚ÇÅ ‚â´[l] (g‚ÇÇ ‚â´[l] g‚ÇÉ)) := by simp only [comp, Category.assoc, eqRebaseAssoc, eqRebase]

@[simp]
def eqRebaseIdComp  {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} : (x ‚ü∂[(ùüô c) ‚â´ f] y) ‚âÉ (x ‚ü∂[f] y)  := eqRebase (id_comp f)

@[simp]
def eqRebaseCompId  {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} : (x ‚ü∂[f ‚â´ (ùüô d) ] y)  ‚âÉ (x ‚ü∂[f] y) := eqRebase (comp_id f)

@[simp]
lemma tauto_comp {e e' e'' : E} {g : e ‚ü∂ e'} {g' : e' ‚ü∂ e''} : tauto (g ‚â´ g') = eqRebase (P.map_comp g g').symm (tauto g ‚â´[l] tauto g') := rfl

@[simp]
lemma eqRebase_hom {c d : C} {f f' : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {g : x ‚ü∂[f] y} {h : f = f'} : (eqRebase h g).hom = g.hom := rfl

@[simp]
lemma tauto_comp_hom {e e' e'' : E} {g : e ‚ü∂ e'} {g' : e' ‚ü∂ e''} : (tauto (P:= P) g ‚â´[l] tauto (P:= P) g').hom = g ‚â´ g' := rfl


namespace Vertical

def vertBasedLiftEquiv {c : C} {x y : P‚Åª¬π c} : (x ‚ü∂ y) ‚âÉ (x ‚ü∂[ùüô c] y) where
  toFun := fun g ‚Ü¶ ‚ü®g.1, by simp [g.2]‚ü©
  invFun := fun g ‚Ü¶ g
  left_inv := by intro g; simp
  right_inv := by intro g; simp

end Vertical

end BasedLift


class IsoBasedLift {C E : Type*} [Category C] [Category E] {P : E ‚•§ C} {c d : C} (f : c ‚ü∂ d) [IsIso f] (x : P‚Åª¬π c) (y : P‚Åª¬π d) extends (x ‚ü∂[f] y) where
  is_iso_hom : IsIso hom


/-- With this definition IsoBasedLift_inv becomes computable. -/
class IsoBasedLift' {C E : Type*} [Category C] [Category E] {P : E ‚•§ C} {c d : C} (f : c ‚âÖ d) (x : P‚Åª¬π c) (y : P‚Åª¬π d)  extends ((x : E) ‚âÖ y) where
  -- The isomorphism lies over f
  eq : eqToHom (x.over) ‚â´ f.hom = (P.map hom) ‚â´ eqToHom (y.over) -- toIso.hom

namespace IsoBasedLift
variable {P : E ‚•§ C} {c d : C} {f : c ‚ü∂ d} [IsIso f] {x : P‚Åª¬π c} {y : P‚Åª¬π d}
notation x " ‚ü∂[‚âÖ" f "] " y => IsoBasedLift (P:= _) f x y

@[simp]
instance instIsoOfIsoBasedLift (g : (x ‚ü∂[‚âÖf] y)) : IsIso g.hom := g.is_iso_hom

/-- Coercion from IsoBasedLift to BasedLift -/
instance : Coe (x ‚ü∂[‚âÖf] y) (x ‚ü∂[f] y) where
  coe := fun l => ‚ü®l.hom, l.over‚ü©

namespace Vertical

noncomputable
def isoVertBasedLiftEquiv {c : C} {x y : P‚Åª¬π c} : (x ‚âÖ y) ‚âÉ (x ‚ü∂[‚âÖ(ùüô c)] y) where
  toFun := fun g => ‚ü®‚ü®g.hom.1, by simp [g.hom.2]‚ü©, by use g.inv.1; simp; cases g; aesop‚ü©
  invFun := fun g => {
    hom := ‚ü®g.hom , by simp‚ü©
    inv := ‚ü® (asIso g.hom).inv , by simp‚ü©
    hom_inv_id := by aesop
    inv_hom_id := by aesop
  }
  left_inv := by intro Œ±; dsimp; ext; rfl
  right_inv := by intro Œ±; dsimp

end Vertical

noncomputable
def IsoBasedLift_inv (g : x ‚ü∂[‚âÖf] y) : (y ‚ü∂[‚âÖ inv f] x) where
  hom := inv g.hom
  over := by simp only [Iso.symm_hom, Functor.map_inv, BasedLift.over_base, IsIso.inv_comp, inv_eqToHom, IsIso.Iso.inv_hom,
  assoc, eqToHom_trans, eqToHom_refl, comp_id]
  is_iso_hom := IsIso.inv_isIso

end IsoBasedLift


namespace Lift
variable {P : E ‚•§ C}

instance  : CoeOut (Lift P f y) (Œ£ x : E, (x : E) ‚ü∂ y) where
  coe := fun l ‚Ü¶ ‚ü®l.src, l.lift.hom‚ü©

@[simp, aesop forward safe]
lemma over_base (f : c ‚ü∂ d) (y : P‚Åª¬π d) (g : Lift P f y) : P.map g.lift.hom = (eqToHom (g.src.over)) ‚â´ f ‚â´ eqToHom (y.over).symm  := by simp only [BasedLift.over_base]

/-- Regarding a morphism in Lift P f as a morphism in the total category E. -/
instance  : CoeDep (Lift P f y) (l : Lift P f y) ((l.src : E) ‚ü∂ (y : E)) where
  coe := l.lift.hom
end Lift


/-- A lift g : x ‚ü∂[f] y over f is cartesian if for every morphism u in the base and every lift g' : x ‚ü∂[u ‚â´ f] z over u ‚â´ f, there is a unique lift l : y ‚ü∂[u] z over u such that l ‚â´ g = g'. -/
class CartesianBasedLift {P : E ‚•§ C} {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} (g : x ‚ü∂[f] y) where
uniq_lift : ‚àÄ ‚¶Éc' : C‚¶Ñ ‚¶Éz : P‚Åª¬π c'‚¶Ñ (u : c' ‚ü∂ c) (g' : z ‚ü∂[u ‚â´ f]  y), Unique { l :  z ‚ü∂[u] x // (BasedLift.comp l g) = g' }

/-- A morphism g : x ‚ü∂[f] y over f is cocartesian if for all morphisms u in the base and g' : x ‚ü∂[f ‚â´ u] z over f ‚â´ u, there is a unique morphism l : y ‚ü∂[u] z over u such that g ‚â´ l = g'. -/
-- @[simp]
class CoCartesianBasedLift {P : E ‚•§ C} {c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} (g : x ‚ü∂[f] y) where
uniq_colift : ‚àÄ ‚¶Éd' : C‚¶Ñ ‚¶Éz : P‚Åª¬π d'‚¶Ñ (u : d ‚ü∂ d') (g' : x ‚ü∂[f ‚â´ u]  z), Unique { l :  y ‚ü∂[u] z // (BasedLift.comp g l) = g' }


namespace CartesianBasedLift
open BasedLift

variable {P : E ‚•§ C} {c' c d : C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {x' : P‚Åª¬π c'} (g : x ‚ü∂[f] y) [CartesianBasedLift (P:= P) g]

/-- The canonical map from a lift g' : x' ‚ü∂[u ‚â´ f] y to the cartesian lift of f. -/
@[simp]
def gaplift (u : c' ‚ü∂ c) (g' : x' ‚ü∂[u ‚â´ f] y) : x' ‚ü∂[u] x := (CartesianBasedLift.uniq_lift (P:= P) (f:= f) (g:= g) (z:= x') u g').default.val

/-- The composition of the gap map and the cartesian lift is the given lift -/
@[simp]
lemma gaplift_property (u : c' ‚ü∂ c) (g' : x' ‚ü∂[u ‚â´ f] y) : ((gaplift g u g') ‚â´[l] g) = g' := (CartesianBasedLift.uniq_lift (P:= P) (f:= f) (g:= g) (z:= x') u g').default.property

/-- A variant of the gaplift property isolating the equality of morphisms in the total category. -/
@[simp]
lemma gaplift_hom_property (u : c' ‚ü∂ c) (g' : x' ‚ü∂[u ‚â´ f] y) : (gaplift g u g').hom ‚â´  g.hom = g'.hom := by rw [‚Üê BasedLift.comp_hom _ _]; congr 1; exact gaplift_property g u g'

/-- The uniqueness part of the universal property of the gap lift. -/
@[simp]
lemma gaplift_uniq {u : c' ‚ü∂ c} (g' : x' ‚ü∂[u ‚â´ f] y) (v : x' ‚ü∂[u] x) (hv : (v ‚â´[l] g) = g') : v = gaplift (g:= g) u g' := by simp [gaplift]; rw [‚Üê (CartesianBasedLift.uniq_lift (P:= P) (f:= f) (g:= g) (z:= x') u g').uniq ‚ü®v,hv‚ü©]

/-- A variant of the  uniqueness lemma. -/
@[simp]
lemma gaplift_uniq' {u : c' ‚ü∂ c} (v : x' ‚ü∂[u] x) (v' : x' ‚ü∂[u] x) (hv : (v ‚â´[l] g) = v' ‚â´[l] g) : v = v' := by rw [gaplift_uniq g (v' ‚â´[l] g) v hv]; symm; apply gaplift_uniq; rfl

/-- The composition of gap lifts with respect to morphisms u : c' ‚ü∂ c and u' : c'' ‚ü∂ c  is the gap lift of the composition u' ‚â´ u. -/
@[simp]
lemma gaplift_comp {u : c' ‚ü∂ c} {u' : c'' ‚ü∂ c'} {x'' : P‚Åª¬π c''} (g' : x' ‚ü∂[u ‚â´ f] y) [CartesianBasedLift (P:= P) (f:= u ‚â´ f) g'] (g'' : x'' ‚ü∂[u' ‚â´ u ‚â´ f] y) :
BasedLift.comp (gaplift  (g:= g') u' g'') (gaplift (g:= g) u g') = gaplift (g:= g) (u' ‚â´ u) (BasedLift.eqRebaseAssoc.invFun g'') := by refine gaplift_uniq (f:= f) g (BasedLift.eqRebaseAssoc.invFun g'') (BasedLift.comp (gaplift  (g:= g') u' g'') (gaplift (g:= g) u g')) (by rw [BasedLift.assoc]; simp only [gaplift_property])

/-- Cartesian based lifts are closed under composition. -/
instance instComp  {c d d' : C} {f‚ÇÅ : c ‚ü∂ d} {f‚ÇÇ : d ‚ü∂ d'} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {z : P‚Åª¬π d'} (g‚ÇÅ : x ‚ü∂[f‚ÇÅ] y) [CartesianBasedLift (P:= P) g‚ÇÅ] (g‚ÇÇ : y ‚ü∂[f‚ÇÇ] z) [CartesianBasedLift (P:= P) g‚ÇÇ] : CartesianBasedLift (P:= P) (g‚ÇÅ ‚â´[l] g‚ÇÇ) where
  uniq_lift := fun c' w u g' => {
    default := ‚ü®gaplift g‚ÇÅ u (gaplift g‚ÇÇ (u ‚â´ f‚ÇÅ) (eqRebaseAssoc.invFun g')), by rw [‚Üê BasedLift.assoc_inv, gaplift_property g‚ÇÅ _ _, gaplift_property g‚ÇÇ _ _]; simp‚ü©
    uniq := by intro ‚ü®l, hl‚ü©; simp; apply gaplift_uniq; apply gaplift_uniq; rw [BasedLift.assoc]; simp; exact hl}

/-- The cancellation lemma for cartesian based lifts. If  `g‚ÇÇ : y ‚ü∂[f‚ÇÇ] z` and `g‚ÇÅ ‚â´[l] g‚ÇÇ : z ‚ü∂[f‚ÇÇ] z` are cartesian then `g‚ÇÅ` is cartesian. -/
@[simp]
lemma instCancel {g‚ÇÅ : x ‚ü∂[f‚ÇÅ] y} {g‚ÇÇ : y ‚ü∂[f‚ÇÇ] z} [CartesianBasedLift (P:= P) g‚ÇÇ] [CartesianBasedLift (g‚ÇÅ ‚â´[l] g‚ÇÇ)] : CartesianBasedLift g‚ÇÅ where
  uniq_lift := fun c' z' u‚ÇÅ g‚ÇÅ' => {
    default := {
      val := gaplift (g:= g‚ÇÅ ‚â´[l]  g‚ÇÇ) u‚ÇÅ (eqRebaseAssoc (g‚ÇÅ' ‚â´[l] g‚ÇÇ))
      property := by apply gaplift_uniq' g‚ÇÇ _ (g‚ÇÅ'); rw [BasedLift.assoc]; rw [ gaplift_property _ _ _]; simp
    }
    uniq := by intro l
               cases' l with l hl
               have : (l ‚â´[l] (g‚ÇÅ ‚â´[l] g‚ÇÇ)) = eqRebaseAssoc (g‚ÇÅ' ‚â´[l] g‚ÇÇ) := by simp only [‚Üê BasedLift.assoc_inv]; rw [hl]; simp
               simp
               apply gaplift_uniq (g‚ÇÅ ‚â´[l] g‚ÇÇ) (eqRebaseAssoc (g‚ÇÅ' ‚â´[l] g‚ÇÇ)) l (this)
  }

end CartesianBasedLift


section CoCartesianBasedLift
variable {P : E ‚•§ C} {c d d': C} {f : c ‚ü∂ d} {x : P‚Åª¬π c} {y : P‚Åª¬π d} {y' : P‚Åª¬π d'} (g : x ‚ü∂[f] y) [CoCartesianBasedLift (P:= P) g]

@[simp]
def cogaplift (u : d ‚ü∂ d') (g' : x ‚ü∂[f ‚â´ u] y') : y ‚ü∂[u] y' :=
(CoCartesianBasedLift.uniq_colift (P:= P) (f:= f) (g:= g) (z:= y') u g').default.val

/-- The composition of the cogap map and the cocartesian lift is the given lift -/
@[simp]
lemma cogaplift_property (u : d ‚ü∂ d') (g' : x ‚ü∂[f ‚â´ u] y') : BasedLift.comp g (cogaplift g u g') = g' := (CoCartesianBasedLift.uniq_colift (P:= P) (f:= f) (g:= g) (z:= y') u g').default.property

@[simp]
lemma cogaplift_hom_property (u : d ‚ü∂ d') (g' : x ‚ü∂[f ‚â´ u] z) : g.hom ‚â´ (cogaplift g u g').hom = g'.hom := by rw [‚Üê BasedLift.comp_hom _ _]; congr 1; exact cogaplift_property g u g'

/-- The uniqueness part of the universal property of the cogap lift -/
@[simp]
lemma cogaplift_uniq  {u : d ‚ü∂ d'} (g' : x ‚ü∂[f ‚â´ u] y') (v : y ‚ü∂[u] y') (hv : BasedLift.comp g v = g') : v = cogaplift (g:= g) u g' := by
simp [cogaplift]
rw [‚Üê (CoCartesianBasedLift.uniq_colift (P:= P) (f:= f) (g:= g) (z:= y') u g').uniq ‚ü®v,hv‚ü©]

/-- The composition of cogap maps with respect two gaps u: d ‚ü∂ d' and u' : d' ‚ü∂ d''  is the cogap lift of the composition u ‚â´ u'. -/
@[simp]
lemma cogaplift_comp {u : d ‚ü∂ d'} {u' : d' ‚ü∂ d''} {y'' : P‚Åª¬π d''} (g' : x ‚ü∂[f ‚â´ u] y') [CoCartesianBasedLift (P:= P) g'] (g'' : x ‚ü∂[(f ‚â´ u) ‚â´ u'] y'') : BasedLift.comp  (cogaplift (g:= g) u g') (cogaplift (g:= g') u' g'') = cogaplift (g:= g) (u ‚â´ u') (BasedLift.eqRebaseAssoc.toFun g'') := by refine cogaplift_uniq (f:= f) g (BasedLift.eqRebaseAssoc.toFun g'') ( BasedLift.comp  (cogaplift (g:= g) u g') (cogaplift (g:= g') u' g'')) (by rw [‚Üê BasedLift.assoc_inv]; simp only [cogaplift_property])

end CoCartesianBasedLift


@[simp]
abbrev CartesianMorphism {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) := CartesianBasedLift (P:= P) (BasedLift.tauto g) -- note `def` did not work with instance synthesis in gapmap below and also makes the CartesianMorphism a function not a class

section CartesianMorphism
open CartesianBasedLift

variable {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) [CartesianMorphism (P:= P) g]

def gapmap' {x' : E} (u : P.obj x' ‚ü∂ P.obj x) (g' : (Fib.tauto x') ‚ü∂[u ‚â´ P.map g] (Fib.tauto y)) : x' ‚ü∂ x :=  (gaplift (BasedLift.tauto g) u g').hom

/-- The composition of the gap map and the cartesian lift is the given lift -/
@[simp]
lemma gapmap_property'  (x' : E) (u : P.obj x' ‚ü∂ P.obj x) (g' : (Fib.tauto x') ‚ü∂[u ‚â´ P.map g] (Fib.tauto y)) : (gapmap' g  u g' : x' ‚ü∂ x ) ‚â´ g = g'.hom := gaplift_hom_property (BasedLift.tauto g) u g'

/-- The uniqueness part of the universal property of the gap map -/
@[simp]
lemma gapmap_uniq' {x' : E} (u : P.obj x' ‚ü∂ P.obj x) (g' : (Fib.tauto x') ‚ü∂[u ‚â´ P.map g] (Fib.tauto y)) (v : (Fib.tauto x') ‚ü∂[u] (Fib.tauto x)) (hv : BasedLift.comp v (BasedLift.tauto g) = g') : v.hom = gapmap' g u g' := by congr 1; exact gaplift_uniq (BasedLift.tauto g) g' v hv

end CartesianMorphism


@[simp]
abbrev CoCartesianMorphism {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) := CoCartesianBasedLift (P:= P) (c:= P.obj x) (d:= P.obj y) (BasedLift.tauto g) -- note `def` did not work with instance synthesis in gapmap below and also makes the CartesianMorphism a function not a class

section CoCartesianMorphism
variable {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) [CoCartesianMorphism (P:= P) g]

def cogapmap {y' : E} (u : P.obj y ‚ü∂ P.obj y') (g' : (Fib.tauto x) ‚ü∂[P.map g ‚â´ u] (Fib.tauto y')) : y ‚ü∂ y' :=  (cogaplift (BasedLift.tauto g) u g').hom

@[simp]
lemma cogapmap_property  (y' : E) (u : P.obj y ‚ü∂ P.obj y') (g' : (Fib.tauto x) ‚ü∂[P.map g ‚â´ u] (Fib.tauto y')) : g ‚â´ (cogapmap g  u g' : y ‚ü∂ y' ) = g'.hom := cogaplift_hom_property (BasedLift.tauto g) u g'

@[simp]
lemma cogapmap_uniq {y' : E} (u : P.obj y ‚ü∂ P.obj y') (g' : (Fib.tauto x) ‚ü∂[P.map g ‚â´ u] (Fib.tauto y')) (v : (Fib.tauto y) ‚ü∂[u] (Fib.tauto y')) (hv :  (g ‚â´[l] v) = g') : v.hom = cogapmap g u g' := by congr 1; exact cogaplift_uniq (BasedLift.tauto g) g' v hv

end CoCartesianMorphism

-- def isCartesianMorphism {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) : Prop := ‚àÄ ‚¶Éc: C‚¶Ñ ‚¶Éz: P‚Åª¬π c‚¶Ñ (u : c ‚ü∂ P.obj x) (g' : z ‚ü∂[u ‚â´ P.map g] Fib.tauto y), ‚àÉ! (l : z ‚ü∂[u] x), l.hom ‚â´ g = g'.hom
/-- A morphism is cartesian if there is a uniqe gap map. -/
def isCartesianMorphism {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) : Prop := ‚àÄ ‚¶Éz: E‚¶Ñ (u : P.obj z ‚ü∂ P.obj x) (g' :  Fib.tauto z ‚ü∂[u ‚â´ P.map g] y), ‚àÉ! (l : Fib.tauto z ‚ü∂[u] x), (l.hom ‚â´ g) = g'.hom

/-- The class of cartesian morphisms -/
@[simp]
def CartMor (P : E ‚•§ C) : MorphismProperty E :=  fun _ _ g => isCartesianMorphism (P:= P) g --Nonempty (CartesianMorphism (P:= P) g)


namespace CartMor
open MorphismProperty CartesianBasedLift BasedLift

variable {P : E ‚•§ C} {x y : E}

noncomputable
def gapmap (g : x ‚ü∂ y) (gcart : CartMor P g) {z : E} (u : P.obj z ‚ü∂ P.obj x) (g' : Fib.tauto z ‚ü∂[u ‚â´ P.map g] y) : (z : E) ‚ü∂ x :=  (Classical.choose (gcart u g')).hom

@[simp]
lemma gapmap_over {z : E} {u : P.obj z ‚ü∂ P.obj x} {g' : Fib.tauto z ‚ü∂[u ‚â´ P.map g] Fib.tauto y} : P.map (gapmap g gcart u g') = u := by simp [gapmap]

/-- The composition of the gap map of a map g' and the cartesian lift g is the given map g'. -/
@[simp]
lemma gapmap_property {g : x ‚ü∂ y} {gcart : CartMor P g} {z : E} {u : P.obj z ‚ü∂ P.obj x} {g' : Fib.tauto z ‚ü∂[u ‚â´ P.map g] y} : (gapmap g gcart u g') ‚â´ g = g'.hom := by apply (Classical.choose_spec (gcart u g')).1

@[simp]
lemma gapmap_uniq {z : E} {u : P.obj z ‚ü∂ P.obj x} {g' : Fib.tauto z ‚ü∂[u ‚â´ P.map g] Fib.tauto y}  (v : Fib.tauto z ‚ü∂[u] x) (hv : v.hom ‚â´ g = g'.hom) : v.hom = gapmap g gcart u g' := by
simp [gapmap]
have : v = Classical.choose (gcart u g') := by refine (Classical.choose_spec (gcart u g')).2 v hv
rw [this]

@[simp]
lemma gapmap_uniq' (g : x ‚ü∂ y) (gcart : CartMor P g) {c : C} {z : P‚Åª¬π c} (v‚ÇÅ : (z : E) ‚ü∂ x) (v‚ÇÇ : (z : E) ‚ü∂ x) (hv : v‚ÇÅ ‚â´ g = v‚ÇÇ ‚â´ g) (hv' : P.map v‚ÇÅ = P.map v‚ÇÇ) : v‚ÇÅ = v‚ÇÇ := by
let v‚ÇÅ' := tauto (P:= P) v‚ÇÅ
let v‚ÇÇ' := tauto (P:= P) v‚ÇÇ
let g' := v‚ÇÇ' ‚â´[l] tauto g
have : P.map v‚ÇÅ ‚â´ P.map g = P.map v‚ÇÇ ‚â´ P.map g  := by rw [‚Üê P.map_comp, ‚Üê P.map_comp, hv]
have hv‚ÇÅ : v‚ÇÅ'.hom ‚â´ g = g'.hom := by simp [Fib.tauto_over v‚ÇÅ, hv]
have hv‚ÇÇ : v‚ÇÇ'.hom ‚â´ g = g'.hom := by simp
have hv‚ÇÇ' : (eqRebase hv'.symm v‚ÇÇ').hom ‚â´ g = (eqRebase (this.symm) g').hom := by simp [hv‚ÇÇ]
have H' := (gcart (P.map v‚ÇÅ) (eqRebase (this.symm) g')).unique hv‚ÇÅ hv‚ÇÇ'
injection H'


/-- Axiom of choice gives for a mere (unique) existence of gap map the data of a unique gap map, and as such a structure of a cartesian morphism. -/
noncomputable
instance instCartOfisCart {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) (gcart: CartMor P g) : CartesianMorphism (P:= P) g :=
{
  uniq_lift := fun c' x' u g' =>
  let u‚ÇÅ := eqToHom x'.over ‚â´ u;
  let g‚ÇÅ := BasedLift.eqRebaseAssoc.invFun (BasedLift.eqRebaseToHom g');
  {
    default := {
      val := ‚ü®(Classical.choose (gcart u‚ÇÅ g‚ÇÅ)).hom, by simp only [BasedLift.over_base, eqToHom_refl, comp_id, id_comp]‚ü©
      property := by ext; simp; exact (Classical.choose_spec (gcart u‚ÇÅ g‚ÇÅ)).1
    }
    uniq := by intro l
               ext
               have H : l.1.hom ‚â´ g = g'.hom := by simp [l.2]; aesop
               let H' := gapmap_uniq' g gcart (l.1.hom) (gapmap g gcart u‚ÇÅ g‚ÇÅ) (by rw [H, gapmap_property]; simp) (by simp)
               rw [H']; rfl
  }
}

@[simp]
lemma cart_id (e : E) : CartMor P (ùüô e) := fun z u g' ‚Ü¶ by
use ‚ü® (BasedLift.eqRebase ((whisker_eq u (P.map_id e)).trans (comp_id _))).toFun g', by aesop‚ü©
simp; intro v hv; ext; aesop

-- ‚ü®{
--   uniq_lift := fun c z u g' ‚Ü¶ {
--     default := ‚ü® (BasedLift.overRebase ((whisker_eq u (P.map_id e)).trans (comp_id _))).toFun g', by aesop‚ü©
--     uniq := by simp; intro v hv; ext; aesop
--   }
-- }‚ü©

/-- Cartesian morphisms are closed under composition. -/
lemma cart_comp : StableUnderComposition (CartMor P) := fun x y z f g hf hg w u g' => by
cases' (hg (u ‚â´ P.map f) ((BasedLift.eqRebase ((u ‚â´= P.map_comp f g).trans (Category.assoc u _ _).symm )).toFun g')) with lg hlg
cases' (hf u lg) with lf hlf
use lf
constructor
¬∑ simp only [Fib.tauto_over, CartMor, ‚Üê Category.assoc, hlf.1, hlg.1, eqRebase]
¬∑ intro v hv
  have : v.hom ‚â´ f = lg.hom := (BasedLift.comp_hom_over).mp (hlg.2 (v ‚â´[l] f) (hv ‚ñ∏ assoc v.hom f g))
  apply hlf.2 v this

/-- Every isomorphism is cartesian. -/
lemma cart_iso {x y : E} (g : x ‚ü∂ y) [IsIso g] : CartMor P g := fun z u g' => by
use (BasedLift.eqRebase (by simp)).toFun (g' ‚â´[l] BasedLift.tauto (inv g))
simp
intro v hv
congr! 1
aesop

/-- The property CartMor respect isomorphisms -/
lemma cart_iso_closed : RespectsIso (CartMor P) where
  left := fun e g hg => by apply cart_comp; exact cart_iso e.hom; assumption
  right := fun e g hg => by apply cart_comp; assumption; exact cart_iso e.hom

open IsPullback
/--Cartesian morphisms are closed under base change: Given a pullback square
```
  P---g'-->X
  |        |
 f'        f
  |        |
  v        v
  Y---g--->Z
```
if g is cartesian, then so is g'.-/
lemma cart_pullback [PreservesLimitsOfShape WalkingCospan P] : StableUnderBaseChange (CartMor P) := fun x y w z f g f' g' pb gcart  => by
intro w' u k
have pbw : P.map g' ‚â´ P.map f = P.map f' ‚â´ P.map g := by rw [‚Üê P.map_comp, ‚Üê P.map_comp, pb.w]
have pbw' : P.map k.hom ‚â´ P.map f  = (u ‚â´ P.map f') ‚â´ P.map g := by rw [Category.assoc]; rw [u ‚â´= pbw.symm]; simp only [Fib.tauto_over, over_base, eqToHom_refl, comp_id, id_comp, Category.assoc]
have hk : P.map k.hom = u ‚â´ P.map g' := by simp only [Fib.tauto_over, over_base, eqToHom_refl, comp_id, id_comp, Category.assoc]
let v' :  w' ‚ü∂ y := gapmap g gcart (u ‚â´ P.map f') (eqRebase pbw' (eqRebase (hk.symm) k ‚â´[l] tauto f))
have : k.hom ‚â´ f = v' ‚â´ g := by simp [v', gapmap_property]
let pbc‚ÇÅ : PullbackCone f g := PullbackCone.mk k.hom v' this
let pb‚ÇÅ := pb |> IsPullback.flip |> isLimit
let pb‚ÇÇ := isLimitPullbackConeMapOfIsLimit P (f:= f) (g:= g) pb.w.symm (pb |> IsPullback.flip |> isLimit)
let v : w' ‚ü∂ w := pb‚ÇÅ.lift pbc‚ÇÅ
have hv‚ÇÅ : P.map v ‚â´ P.map g' = P.map k.hom := by rw [‚Üê P.map_comp]; congr 1; exact pb‚ÇÅ.fac pbc‚ÇÅ WalkingCospan.left
have hu‚ÇÅ : u ‚â´ P.map g' = P.map k.hom := by simp only [Fib.tauto_over, over_base, eqToHom_refl, comp_id, id_comp]
have hv‚ÇÇ' : v ‚â´ f' = v' := pb‚ÇÅ.fac pbc‚ÇÅ WalkingCospan.right
have hv‚ÇÇ : P.map v ‚â´ P.map f' = u ‚â´ P.map f' := by rw [‚Üê P.map_comp, hv‚ÇÇ']; simp only [gapmap_over]
have hv‚ÇÉ : P.map v = u := by apply PullbackCone.IsLimit.hom_ext pb‚ÇÇ; simp only [PullbackCone.mk_œÄ_app_left]; rw [hv‚ÇÅ, ‚Üê hu‚ÇÅ]; simp only [PullbackCone.mk_œÄ_app_right]; rw [hv‚ÇÇ]
use ‚ü®v, by rw [hv‚ÇÉ]; simp‚ü©
--dsimp
constructor
¬∑ apply pb‚ÇÅ.fac pbc‚ÇÅ WalkingCospan.left
. intro l hl
  have : (l ‚â´[l] tauto f').hom ‚â´ g = (k ‚â´[l] tauto f).hom := by simp [comp_hom]; rw [pb.w, ‚Üê Category.assoc, hl, ‚Üê comp_tauto_hom]
  have : l.hom ‚â´ f' = v' := by rw [‚Üê comp_tauto_hom]; apply gapmap_uniq (l ‚â´[l] tauto f') this
  have : l.hom = v := by apply PullbackCone.IsLimit.hom_ext pb‚ÇÅ;
                         ¬∑ simp [cone_fst]; rw [hl]; symm; exact pb‚ÇÅ.fac pbc‚ÇÅ WalkingCospan.left
                         ¬∑ simp [cone_snd]; rw [this]; symm; exact pb‚ÇÅ.fac pbc‚ÇÅ WalkingCospan.right
  ext; assumption



namespace Vertical
open BasedLift CartesianBasedLift FibCat

/- Vertical cartesian lifts are isomorphism. -/
@[simps]
def vertCartIso {P : E ‚•§ C} {c: C} {e e' : P‚Åª¬π c} (g : e ‚ü∂ e') [CartesianBasedLift (P:= P) (ofFibHom g)] : e ‚âÖ e' where
  hom := g
  inv := gaplift (ofFibHom g) (ùüô c) (id e' ‚â´[l] id e')
  --apply gaplift_property;
  --apply gaplift_uniq' (ofFibHom g) (ofFibHom g);
  inv_hom_id := by rw [‚Üê comp_id (ùüô e')]; apply FibCat.hom_ext; apply gaplift_hom_property
  hom_inv_id := by rw [‚Üê comp_id (ùüô e)]
                   let g' : e' ‚ü∂[ùüô c] e := ofFibHom (gaplift (ofFibHom g) (ùüô c) (id e' ‚â´[l] id e'))
                   have : ((ofFibHom g ‚â´[l] g') ‚â´[l] ofFibHom g) = (BasedLift.id e ‚â´[l] BasedLift.id e) ‚â´[l](ofFibHom g) := by
                                          simp [BasedLift.assoc]
                                          have H : ( (gaplift (ofFibHom g) (ùüô c) (id e' ‚â´[l] id e')) ‚â´[l] ofFibHom g) = (BasedLift.id e' ‚â´[l] BasedLift.id e') := by apply gaplift_property
                                          have H' := comp_hom_over.mp H
                                          simp at H'
                                          rw [H']; simp
                   have H := gaplift_uniq' (ofFibHom g) ((ofFibHom g) ‚â´[l] g') (BasedLift.id e ‚â´[l] BasedLift.id e) (this)
                   apply FibCat.hom_ext
                   dsimp
                   have H' := comp_hom_over.mp H
                   simp at H'; simp [H']

/-There is an IsoBasedLift between two cartesian morphims over the same base morphism. -/

-- def isoOfGapLift {f : c ‚ü∂ d} {x x' : P‚Åª¬π c} {y : P‚Åª¬π d} {g‚ÇÅ : x ‚ü∂[f] y } {g‚ÇÇ : x' ‚ü∂[f] y} [CartesianBasedLift (P:= P) g‚ÇÅ] [CartesianBasedLift (P:= P) g‚ÇÇ] : x' ‚ü∂[‚âÖ(ùüô c)] x where
--   hom := gaplift g‚ÇÅ (ùüô c) (BasedLift.id x' ‚â´[l] BasedLift.id x)
--   over := _
--   is_iso_hom := _


-- g‚ÇÅ ‚âÖ g‚ÇÇ where
--   hom := gapmap g‚ÇÅ (CartMor P g‚ÇÅ) u g'
--   inv := gapmap g‚ÇÇ (CartMor P g‚ÇÇ) u g'
--   hom_inv_id := by rw [‚Üê comp_id g‚ÇÅ]; apply gapmap_uniq (CartMor P g‚ÇÅ) g' (gapmap g‚ÇÅ (CartMor P g‚ÇÅ) u g') (gapmap_property g‚ÇÅ (CartMor P g‚ÇÅ) u g')
--   inv_hom_id := by rw [‚Üê comp_id g‚ÇÇ]; apply gapmap_uniq (CartMor P g‚ÇÇ) g' (gapmap g‚ÇÇ (CartMor P g‚ÇÇ) u g') (gapmap_property g‚ÇÇ (CartMor P g‚ÇÇ) u g')


end Vertical
end CartMor



@[simp]
def isCoCartesianMorphism {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) : Prop := ‚àÄ ‚¶Éc: C‚¶Ñ ‚¶Éz: P‚Åª¬π c‚¶Ñ (u : P.obj y ‚ü∂ c) (g' : Fib.tauto x ‚ü∂[P.map g ‚â´ u] z), ‚àÉ! (l : Fib.tauto y ‚ü∂[u] z), g ‚â´ l.hom = g'.hom

/-- Axiom of choice gives for mere (unique) existence of cogap map the data of a unique cogap map. -/
instance {P : E ‚•§ C} {x y : E} (g : x ‚ü∂ y) (hcocart: isCoCartesianMorphism (P:= P) g) : Nonempty (CoCartesianMorphism (P:= P) g) := ‚ü®{
  uniq_colift := fun c' x' u g' => {
    default := {
      val := ‚ü®(Classical.choose (hcocart u g')).hom, by aesop‚ü©
      property := by ext; simp; exact (Classical.choose_spec (hcocart u g')).1;
    }
    uniq := by intro l
               ext
               --simp
               have : g ‚â´ l.1.hom = g'.hom := by simp [l.2]; aesop
               congr 1
               refine (Classical.choose_spec (hcocart u g')).2 l.1 this
  }
}‚ü©

@[simp]
def CoCartMor (P : E ‚•§ C): MorphismProperty E :=  fun _ _ f => isCoCartesianMorphism (P:= P) f

section CoCartMor
variable {P : E ‚•§ C}

/-- The identity morphism is cocartesian. -/
@[simp]
lemma cocart_id (e : E) : CoCartMor P (ùüô e) := fun c z u g' ‚Ü¶ by
use ‚ü® (BasedLift.eqRebase ((eq_whisker (P.map_id e) u).trans (id_comp _))).toFun g', by aesop‚ü©
simp; intro v hv; ext; aesop

/-- Cocartesian morphisms are closed under composition. -/
@[simp]
lemma cocart_comp (f : x ‚ü∂ y) (g : y ‚ü∂ z) : CoCartMor (P:= P) f ‚Üí CoCartMor (P:= P) g ‚Üí CoCartMor (P:= P) (f ‚â´ g) := fun hf hg c w u g' ‚Ü¶ by
cases' (hf (P.map g ‚â´ u) ((BasedLift.eqRebase ((P.map_comp f g =‚â´ u ).trans (assoc _ _ u) )).toFun g')) with lf hlf
cases' (hg u lf) with lg hlg
use lg
constructor
¬∑ simp [‚Üê assoc, hlf.1, hlg.1]
¬∑ intro v hv
  let hv' := (BasedLift.comp_hom (BasedLift.tauto g) v).symm ‚ñ∏ (hv ‚ñ∏ (assoc f g v.hom).symm)
  let hlf2 := (hlf.2 (g ‚â´[l] v)) hv'
  have : g ‚â´ v.hom = lf.hom := (BasedLift.comp_hom_over).mp hlf2
  apply hlg.2 v this

end CoCartMor


section CartLift
variable {P : E ‚•§ C} {c d : C}

/-- The type of all cartesian lifts of a given morphism in the base -/
class CartBasedLifts (P : E ‚•§ C) {c d : C} (f : c ‚ü∂ d) (src : P‚Åª¬π c) (tgt : P‚Åª¬π d) extends BasedLift P f src tgt where
is_cart : CartesianBasedLift (P:= P) toBasedLift

instance instHomOfCartBasedLift {c d : C} (f : c ‚ü∂ d) (src : P‚Åª¬π c) (tgt : P‚Åª¬π d) : CoeOut (CartBasedLifts P f src tgt) (src.1 ‚ü∂ tgt.1) where
  coe := fun l ‚Ü¶ l.1.hom

class CartesianLift (f : c ‚ü∂ d) (y : P‚Åª¬π d) extends Lift P f y where
is_cart : CartesianBasedLift (P:= P) lift

class CoCartesianLift (f : c ‚ü∂ d) (x : P‚Åª¬π c) extends CoLift P f x where
is_cart : CoCartesianBasedLift (P:= P) colift

def HasCartesianLift (f : c ‚ü∂ d) (y : P‚Åª¬π d) := Nonempty (CartesianLift (P:= P) f y)

def HasCoCartesianLift (f : c ‚ü∂ d) (x : P‚Åª¬π c) := Nonempty (CoCartesianLift (P:= P) f x)

end CartLift


abbrev Cart ( _ : E ‚•§ C) := E
open CartMor
/-- The subcategory of cartesian arrows -/
instance {P : E ‚•§ C} : Category (Cart P) where
  Hom x y := { f : x ‚ü∂ y |  CartMor (P:= P) f }
  id x := ‚ü®ùüô x, cart_id x‚ü©
  comp := @fun x y z f g => ‚ü® f.1 ‚â´ g.1, cart_comp f.1 g.1 f.2 g.2‚ü©

namespace Cart

/-- The forgetful functor from the category of cartesian morphisms to the total category -/
def forget {P : E ‚•§ C} : Cart P ‚•§ E where
obj := fun x => x
map := @fun x y f => f

end Cart
