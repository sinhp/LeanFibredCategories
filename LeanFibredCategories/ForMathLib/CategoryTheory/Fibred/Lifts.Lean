/-
Copyright (c) 2024 Sina Hazratpour. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sina Hazratpour
-/

import Mathlib.CategoryTheory.Category.Cat
import Mathlib.CategoryTheory.Arrow
import Mathlib.CategoryTheory.Opposites
import Mathlib.CategoryTheory.Equivalence
import Mathlib.CategoryTheory.EqToHom
import Mathlib.CategoryTheory.Sigma.Basic
import Mathlib.CategoryTheory.Limits.Preserves.Basic
import LeanFibredCategories.ForMathlib.Data.Fiber
import LeanFibredCategories.ForMathlib.CategoryTheory.Fibred.Basic

/-!
# Lifts

For a functor `P : E â¥¤ C`, the structure `BasedLift` provides the type of lifts
of a given morphism in the base with fixed source and target in the fibers of `P`.

We provide various useful constructors:
* `BasedLift.tauto` regards a morphism `g` of the domain category `E` as a
  based lift of its image `P g` under functor `P`.
* `BasedLift.id` and `BasedLift.comp` provide the identity and composition of
  based lifts, respectively.

There are also typeclasses `IsLeftAdjoint` / `IsRightAdjoint`, carrying data witnessing
that a given functor is a left or right adjoint.
Given `[IsLeftAdjoint F]`, a right adjoint of `F` can be constructed as `rightAdjoint F`.

`Adjunction.comp` composes adjunctions.

`toEquivalence` upgrades an adjunction to an equivalence,
given witnesses that the unit and counit are pointwise isomorphisms.
Conversely `Equivalence.toAdjunction` recovers the underlying adjunction from an equivalence.

We provide the following notations:
* `x âŸ¶[f] y` for `BasedLift P f x y`
* `f â‰«[l] g` for the composition of based lifts given by `BasedLift.comp f g`

-/

namespace CategoryTheory

open Category Opposite Functor Limits Cones

variable {C E : Type*} [Category C] [Category E]

/-- The type of lifts of a given morphism in the base
with fixed source and target in the fibers of the domain and codomain respectively.-/
@[ext]
structure BasedLift (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (src : Pâ»Â¹ c) (tgt : Pâ»Â¹ d) where
hom : (src : E) âŸ¶ (tgt : E)
over : (P.map hom) â‰« eqToHom (tgt.over) = eqToHom (src.2) â‰« f

section BasedLiftNotation

variable (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) {x : Pâ»Â¹ c} {y : Pâ»Â¹ d}

notation x " âŸ¶[" f "] " y => BasedLift (P:= _) f x y

end BasedLiftNotation

/-- A lift of a morphism in the base with a fixed target in the fiber of
the codomain -/
@[ext]
structure Lift (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (tgt : Pâ»Â¹ d) where
src : Pâ»Â¹ c
lift : BasedLift P f src tgt

/-- A lift of a morphism in the base with a fixed source in the fiber of
the domain -/
@[ext]
structure CoLift (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (src : Pâ»Â¹ c) where
tgt : Pâ»Â¹ d
colift : BasedLift P f src tgt

/-- `HasLift P f y` represents the mere existence of a lift of the morphism `f` with target `y`. -/
def HasLift (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (y : Pâ»Â¹ d) := Nonempty (Lift P f y)

/-- `HasColift P f x` represents the mere existence of a lift of the morphism `f` with source `x`. -/
def HasCoLift (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (x : Pâ»Â¹ c) := Nonempty (CoLift P f x)

namespace BasedLift

variable {P : E â¥¤ C}

@[simp, aesop forward safe]
lemma over_base {c d : C} {f : c âŸ¶ d} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} (g : BasedLift P f x y) : P.map g.hom = eqToHom (x.2) â‰« f â‰« (eqToHom (y.over).symm)  := by simp only [â† Category.assoc _ _ _, â† g.over, assoc, eqToHom_trans, eqToHom_refl, comp_id]

/-- Coercion from BasedLift to the domain category. -/
instance (P : E â¥¤ C) {c d : C} (f : c âŸ¶ d) (x : Pâ»Â¹ c) (y : Pâ»Â¹ d) : CoeOut (BasedLift P f x y) ((x : E) âŸ¶ (y : E)) where
  coe := fun l â†¦ l.hom

/-- `BasedLift.tauto` regards a morphism `g` of the domain category `E` as a
based lift of its image `P g` under functor `P`. -/
@[simps]
def tauto {e e' : E} (g : e âŸ¶ e') : (Fiber.tauto e) âŸ¶[P.map g] (Fiber.tauto e') := âŸ¨g, by simp only [Fiber.tauto, eqToHom_refl, id_comp, comp_id]âŸ©

@[simps]
instance instCoeTautoBasedLift {e e' : E} {g : e âŸ¶ e'} : CoeDep (e âŸ¶ e') (g) (Fiber.tauto e  âŸ¶[P.map g] Fiber.tauto e') where
  coe := tauto g

/-- Two based lifts of the same base morphism are equal if their underlying morphisms are equal in the domain category. -/
lemma hom_ext {c d : C} {f : c âŸ¶ d} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} {gâ‚ gâ‚‚ : x âŸ¶[f] y} (h : gâ‚.hom = gâ‚‚.hom) : gâ‚ = gâ‚‚ := by
  cases gâ‚; cases gâ‚‚; congr

/-- Regarding a based lift of the identity base morphism as a morphism
 of the fiber category.-/
@[simp]
instance instCoeFiberHom {c : C} {x y : Pâ»Â¹ c} : Coe (x âŸ¶[ğŸ™ c] y) (x âŸ¶ y) where
  coe := fun f â†¦ âŸ¨ f.hom , by simp [f.over]âŸ©

/-- BasedLift.ofFiberHom regards a morphism in the fiber category `Pâ»Â¹ c`
as a based lift of the identity morphism of `c`. -/
@[simps]
def ofFiberHom {c : C} {x y : Pâ»Â¹ c} (f : x âŸ¶ y) : x âŸ¶[ğŸ™ c] y := âŸ¨f.1, by simp [f.2]âŸ©

lemma tauto_over_base (f : (P.obj x) âŸ¶ (P.obj y)) (e : (Fiber.tauto x) âŸ¶[f] (Fiber.tauto y)) : P.map e.hom = f := by simp only [Fiber.coe_mk, over_base, eqToHom_refl, comp_id, id_comp]

/-- The identity based lift. -/
@[simp, aesop forward safe]
def id (x : Pâ»Â¹ c) : BasedLift P (ğŸ™ c) x x := âŸ¨ğŸ™ _, by simpâŸ©

lemma id_hom {x : Pâ»Â¹ c} : (id x).hom = ğŸ™ _ := rfl

/-- The composition of based lifts -/
@[simp]
def comp {c d d': C} {f : c âŸ¶ d} {f' : d âŸ¶ d'} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} {z : Pâ»Â¹ d'} (g : x âŸ¶[f] y) (g' : y âŸ¶[f'] z) : x âŸ¶[f â‰« f'] z :=
âŸ¨g.hom â‰« g'.hom, by simp only [P.map_comp]; rw [assoc, over_base g, over_base g']; simp  âŸ©

section
variable (P : E â¥¤ C){c d d': C}{x: Pâ»Â¹ c} {y : Pâ»Â¹ d} {z : Pâ»Â¹ d'} (u : c âŸ¶ d) (v: d âŸ¶ d') (f : x âŸ¶[u] y) (g : y âŸ¶[v] z)
notation f " â‰«[l] " g => BasedLift.comp f g
end

/-- The underlying morphism of a composition of based lifts is the composition of the underlying morphisms. -/
lemma comp_hom  {c d d': C} {fâ‚ : c âŸ¶ d} {fâ‚‚ : d âŸ¶ d'} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} {z : Pâ»Â¹ d'} (gâ‚ : x âŸ¶[fâ‚] y) (gâ‚‚ : y âŸ¶[fâ‚‚] z) : (gâ‚ â‰«[l] gâ‚‚).hom = gâ‚.hom â‰« gâ‚‚.hom := rfl

@[simp]
lemma comp_hom_aux {c d d': C} {fâ‚ : c âŸ¶ d} {fâ‚‚ : d âŸ¶ d'} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} {z : Pâ»Â¹ d'} {gâ‚ : x âŸ¶[fâ‚] y} {gâ‚‚ : y âŸ¶[fâ‚‚] z} {h : x âŸ¶[fâ‚ â‰« fâ‚‚] z} : (gâ‚ â‰«[l] gâ‚‚) = h â†” gâ‚.hom â‰« gâ‚‚.hom = h.hom := by
constructor
Â· intro H; rw [â† H]; simp
Â· intro H; ext; simp [H]

lemma comp_tauto_hom {x y z : E} {f : P.obj x âŸ¶ P.obj y} {l : Fiber.tauto x âŸ¶[f] (Fiber.tauto y)} {g : y âŸ¶ z} : (l â‰«[l] tauto g).hom = l.hom â‰« g := rfl

/-- Cast a based lift along an equality of the base morphisms. -/
@[simps]
def cast {c d : C} {f f' : c âŸ¶ d} {x : Pâ»Â¹ c} {y : Pâ»Â¹ d} (h : f = f') : (x âŸ¶[f] y) â‰ƒ (x âŸ¶[f'] y) where
  toFun := fun g â†¦ âŸ¨g.hom, by rw [â†h, g.over]âŸ©
  invFun := fun g â†¦ âŸ¨g.hom, by rw [h, g.over]âŸ©
  left_inv := by intro g; simp
  right_inv := by intro g; simp





end BasedLift



end CategoryTheory
